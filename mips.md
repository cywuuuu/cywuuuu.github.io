#### mips 注意事项

这 32 个通用寄存器有两种命名方式，一种是按序号命名 `$0~$31`（注意前面有个美元的符号），一种就是按功能命名，如下表：

![img](http://cscore.buaa.edu.cn/tutorial/mips/mips-1/assets/2.1.3.1.png)

其中 usage 那一列可能暂时不好理解，没有关系，在之后的学习中会慢慢用到。特别地，对于 `$0` 和 `$1` 两个寄存器：

- `$0` 一般不能用于赋值，但这不代表你对它赋值就是错的。在实际中，你可以对 `$0` 进行赋值，但它的值会始终保持为 0。也就是说对 `$0` 赋值并不违反语法，但没有实际效果。
- `$1` 保留给汇编器，一般不使用此寄存器(使用该寄存器可能会导致难以发现的 bug，具体原因请在编写 MIPS 汇编时注意扩展指令是如何翻译成普通指令的)

### **三个特殊寄存器**

- **PC（Program Counter）**：这个寄存器想必已经在理论课上讲解过了。它用于存储当前 CPU 正在执行的指令在内存中的地址。需要注意的是，这个寄存器的值不能用常规的指令进行取值和赋值，但这并不意味着不能做到，只是麻烦一些。那么，怎样对其取值、赋值呢？这可以作为一个思考的题目，在之后的学习中自行探索。（提示：跳转）
- ==**HI**：这个寄存器用于乘除法。它被用来存放每次乘法结果的**高 32 位**，也被用来存放除法结果的**余数**（余数更高）。==
- ==**LO**：HI 的孪生兄弟。它被用来存放每次乘法结果的**低 32 位**，也被用来存放除法结果的**商**。==

## **机器码的指令格式**

32 位的机器码需要一定的格式才能被理解。一般来说，在 MIPS 指令集中，指令分为三种格式：R 型、I 型和 J 型。

- **R 型指令**

R 型指令的操作数最多，一般用于运算指令。例如 `add`、`sub`、`sll` 等。其格式如下（左侧为高位，右侧为低位）：

![img](http://cscore.buaa.edu.cn/tutorial/mips/mips-2/assets/2.2.3.3.png)

- **I 型指令**

I 型指令的特点是有 **16 位的立即数**（偏移也是一样的道理）。因此，I 型指令一般用于 `addi`、`subi`、`ori` 等与立即数相运算的指令（**这里需要注意：在写汇编语言的时候，需要使用负号来标记负数，而不要和机器码一样认为首位的 1 就代表负数**），或 `beq`、`bgtz` 等比较跳转指令，因为它们要让两个寄存器的值相比并让 PC 偏移 offset 这么多，刚好利用了全部的字段。还有存取指令，例如 `sw`、`lw`，它们在使用时需要对地址指定一个偏移值，也会用到立即数字段。

![img](http://cscore.buaa.edu.cn/tutorial/mips/mips-2/assets/2.2.3.4.png)

- **J 型指令**

J 型指令很少，常见的为 `j` 和 `jal`。他们需要直接跳转至某个地址，而非利用当前的 PC 值加上偏移量计算出新的地址，因此需要的位数较多。

![img](http://cscore.buaa.edu.cn/tutorial/mips/mips-2/assets/2.2.3.5.png)